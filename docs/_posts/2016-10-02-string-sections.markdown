---
layout: post
title:  "Figuring out the String Stream"
date:   2016-10-02 21:48:20 +0100
---
This has been a tough couple of days.  It started well when I realized I needed a version of ByteBuffer that could read fields with bit offsets.  I naturally called this BitBuffer.  For the methods that extract fields, I used the same names as in the specification, e.g. getBS, getRS etc.  

The problems started when I needed to extract the string fields (getTU).  I assumed that something was in the data stream, perhaps some sort of offset into to the string stream.  Actually there is nothing in the data stream at all for string fields.  I was confused because the TU fields are listed in a specific place among the other fields, so I naturally assumed there was a reason why the string fields were listed exactly where they were.  Actually I suspect the reason is historic, because older versions did not have a separate string stream.  There were clues in the specification which eventually led me to simply ignore the string fields when reading the data stream, but it took me a while.

Getting access to the string stream in the AcDb:Classes section has proved very tricky.  The ODA specification was very confusing. The method for identifying the start of the string stream is documented in chapter 19 (AcDbObjects) but the Classes section also has a string stream.  Chapter 19 talks about going back 16 bytes from the start of the handles area.  I assume the 'total size in bits' is in some way the offset to the end of the string stream but I could not find any combination that actually worked.  I then realized that I knew where the data stream ended, because I could read class objects until it all went horribly wrong.  It's not like DWG to waste bits, so I assumed the string stream started immediately after the last good-looking class object was read.  It was then relatively easy to read the strings.  Using the same trick of reading strings until it all goes horribly wrong, the number of strings was found to be three times the number of class objects, as expected.  Looking at the following data it was indeed two bytes containing the correct length of the string section followed by the '1' bit.  On comparing the offset to the end of this with the given total size in bits, it was always exactly 192 bits (24 bytes) off. So 24 bytes are not included in the bit size.  Perhaps these 24 bytes are the sentinel and the following 8 bytes, meaning the 'total size in bits' is as measured starting with the 'total size in bits' field itself.  